(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs/BehaviorSubject'), require('rxjs/observable/timer'), require('rxjs/Subject'), require('rxjs/observable/of'), require('rxjs/operators/tap'), require('rxjs/operators/map'), require('rxjs/operators/skip'), require('rxjs/operators/delay'), require('rxjs/operators/filter'), require('rxjs/operators/switchMap'), require('rxjs/operators/combineLatest'), require('rxjs/operators/distinctUntilChanged'), require('@angular/core'), require('rxjs/observable/empty'), require('@angular/common')) :
	typeof define === 'function' && define.amd ? define(['exports', 'rxjs/BehaviorSubject', 'rxjs/observable/timer', 'rxjs/Subject', 'rxjs/observable/of', 'rxjs/operators/tap', 'rxjs/operators/map', 'rxjs/operators/skip', 'rxjs/operators/delay', 'rxjs/operators/filter', 'rxjs/operators/switchMap', 'rxjs/operators/combineLatest', 'rxjs/operators/distinctUntilChanged', '@angular/core', 'rxjs/observable/empty', '@angular/common'], factory) :
	(factory((global['ngx-progressbar'] = global['ngx-progressbar'] || {}, global['ngx-progressbar'].core = {}),global.Rx,global.Rx.Observable,global.Rx,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.ng.core,global.Rx.Observable,global.ng.common));
}(this, (function (exports,BehaviorSubject,timer,Subject,of,tap,map,skip,delay,filter,switchMap,combineLatest,distinctUntilChanged,core,empty,common) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */










function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NgProgressRef = (function () {
    /**
     * @param {?} config
     */
    function NgProgressRef(config) {
        var _this = this;
        this._state = { active: false, value: 0 };
        /**
         * Stream that increments and updates progress state
         */
        this._trickling$ = new Subject.Subject();
        /**
         * Stream that emits when progress state is changed
         */
        this.state$ = new BehaviorSubject.BehaviorSubject(this._state);
        /**
         * Stream that emits when config is changed
         */
        this.config$ = new Subject.Subject();
        /**
             * Trickling stream starts the timer that increment the progress bar continuously
             * This stream makes it possible to use latest config values while incrementing
             */
        this._workerSub$ = this._trickling$.pipe(combineLatest.combineLatest(this.config$), switchMap.switchMap(function (_a) {
            var _b = __read(_a, 2), start = _b[0], latestConfig = _b[1];
            return start ? _this._trickling(latestConfig) : _this._complete(latestConfig);
        })).subscribe();
        this.setConfig(config);
    }
    Object.defineProperty(NgProgressRef.prototype, "isStarted", {
        /**
         * @return {?}
         */
        get: function () {
            return this._state.active;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "started", {
        /**
         * Progress start event
         * @return {?}
         */
        get: function () {
            return this.state$.pipe(map.map(function (state) { return state.active; }), distinctUntilChanged.distinctUntilChanged(), filter.filter(function (active) { return active; }));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "completed", {
        /**
         * Progress ended event
         * @return {?}
         */
        get: function () {
            return this.state$.pipe(map.map(function (state) { return state.active; }), distinctUntilChanged.distinctUntilChanged(), filter.filter(function (active) { return !active; }), skip.skip(1));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NgProgressRef.prototype.start = function () {
        if (!this.isStarted) {
            this.set(this._config.min);
        }
        this._trickling$.next(true);
    };
    /**
     * @return {?}
     */
    NgProgressRef.prototype.complete = function () {
        if (this.isStarted) {
            this._trickling$.next(false);
        }
    };
    /**
     * @param {?=} amount
     * @return {?}
     */
    NgProgressRef.prototype.inc = function (amount) {
        var /** @type {?} */ n = this._state.value;
        if (!this.isStarted) {
            this.start();
        }
        else {
            if (typeof amount !== 'number') {
                if (n >= 0 && n < 20) {
                    amount = 10;
                }
                else if (n >= 20 && n < 50) {
                    amount = 4;
                }
                else if (n >= 50 && n < 80) {
                    amount = 2;
                }
                else if (n >= 80 && n < 99) {
                    amount = 0.5;
                }
                else {
                    amount = 0;
                }
            }
            n = this._clamp(n + amount);
            this.set(n);
        }
    };
    /**
     * @param {?} n
     * @return {?}
     */
    NgProgressRef.prototype.set = function (n) {
        this._setState({ value: this._clamp(n), active: true });
    };
    /**
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype.setConfig = function (config) {
        this._config = Object.assign({}, this._config, config);
        this.config$.next(this._config);
    };
    /**
     * Meant to be used internally and not by user directly
     * Users should use NgProgressManager.destroy(id) instead
     * @return {?}
     */
    NgProgressRef.prototype.destroy = function () {
        this._workerSub$.unsubscribe();
        this._trickling$.unsubscribe();
        this.state$.unsubscribe();
        this.config$.unsubscribe();
    };
    /**
     * @param {?} state
     * @return {?}
     */
    NgProgressRef.prototype._setState = function (state) {
        this._state = Object.assign({}, this._state, state);
        this.state$.next(this._state);
    };
    /**
     * Clamps a value to be between min and max
     * @param {?} n
     * @return {?}
     */
    NgProgressRef.prototype._clamp = function (n) {
        return Math.max(this._config.min, Math.min(this._config.max, n));
    };
    /**
     * Keeps incrementing the progress
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype._trickling = function (config) {
        var _this = this;
        return timer.timer(0, config.trickleSpeed).pipe(tap.tap(function () { return _this.inc(); }));
    };
    /**
     * Completes then resets the progress
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype._complete = function (config) {
        var _this = this;
        return of.of({}).pipe(
        // Completes the progress
        tap.tap(function () { return _this._setState({ value: 100 }); }),
        // Hides the progress bar after a tiny delay
        delay.delay(config.speed * 1.7), tap.tap(function () { return _this._setState({ active: false }); }),
        // Resets the progress state
        delay.delay(config.speed), tap.tap(function () { return _this._setState({ value: 0 }); }));
    };
    return NgProgressRef;
}());
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CONFIG = new core.InjectionToken('config');
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var defaultConfig = {
    meteor: true,
    spinner: true,
    thick: false,
    ease: 'linear',
    spinnerPosition: 'right',
    direction: 'ltr+',
    color: '#1B95E0',
    max: 100,
    min: 8,
    speed: 200,
    trickleSpeed: 300
};
var NgProgress = (function () {
    /**
     * @param {?} config
     */
    function NgProgress(config) {
        /**
         * Stores NgProgressRef instances
         */
        this._instances = {};
        this.config = Object.assign({}, defaultConfig, config);
    }
    /**
     * Returns NgProgressRef by ID
     * @param {?=} id
     * @param {?=} config
     * @return {?}
     */
    NgProgress.prototype.ref = function (id, config) {
        if (id === void 0) { id = 'root'; }
        if (this._instances[id] instanceof NgProgressRef) {
            return this._instances[id];
        }
        else {
            config = Object.assign({}, this.config, config);
            return this._instances[id] = new NgProgressRef(config);
        }
    };
    /**
     * @param {?} config
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.setConfig = function (config, id) {
        if (id === void 0) { id = 'root'; }
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].setConfig(config);
        }
    };
    /**
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.start = function (id) {
        if (id === void 0) { id = 'root'; }
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].start();
        }
    };
    /**
     * @param {?} n
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.set = function (n, id) {
        if (id === void 0) { id = 'root'; }
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].set(n);
        }
    };
    /**
     * @param {?=} n
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.inc = function (n, id) {
        if (id === void 0) { id = 'root'; }
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].inc(n);
        }
    };
    /**
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.complete = function (id) {
        if (id === void 0) { id = 'root'; }
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].complete();
        }
    };
    /**
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.isStarted = function (id) {
        if (id === void 0) { id = 'root'; }
        return (this._instances[id] instanceof NgProgressRef) ? this._instances[id].isStarted : false;
    };
    /**
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.started = function (id) {
        if (id === void 0) { id = 'root'; }
        return (this._instances[id] instanceof NgProgressRef) ? this._instances[id].started : empty.empty();
    };
    /**
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.completed = function (id) {
        if (id === void 0) { id = 'root'; }
        return (this._instances[id] instanceof NgProgressRef) ? this._instances[id].ended : empty.empty();
    };
    /**
     * @param {?=} id
     * @return {?}
     */
    NgProgress.prototype.destroy = function (id) {
        if (id === void 0) { id = 'root'; }
        if (this._instances[id] instanceof NgProgressRef) {
            this._instances[id].destroy();
            this._instances[id] = null;
        }
    };
    /**
     * @return {?}
     */
    NgProgress.prototype.destroyAll = function () {
        var _this = this;
        Object.keys(this._instances).map(function (key) {
            _this._instances[key].destroy();
            _this._instances[key] = null;
        });
    };
    return NgProgress;
}());
NgProgress.decorators = [
    { type: core.Injectable },
];
/** @nocollapse */
NgProgress.ctorParameters = function () { return [
    { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [CONFIG,] },] },
]; };
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @license
 * Copyright ngx-progressbar All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/MurhafSousli/ngx-progressbar/blob/master/LICENSE
 */
var NgProgressComponent = (function () {
    /**
     * @param {?} _ngProgress
     */
    function NgProgressComponent(_ngProgress) {
        this._ngProgress = _ngProgress;
        /**
         * Creates a new instance if id is not already exists
         */
        this.id = 'root';
        /**
         * Initializes inputs from the global config
         */
        this.spinnerPosition = this._ngProgress.config.spinnerPosition;
        this.direction = this._ngProgress.config.direction;
        this.ease = this._ngProgress.config.ease;
        this.color = this._ngProgress.config.color;
        this.meteor = this._ngProgress.config.meteor;
        this.spinner = this._ngProgress.config.spinner;
        this.thick = this._ngProgress.config.thick;
        this.max = this._ngProgress.config.max;
        this.min = this._ngProgress.config.min;
        this.speed = this._ngProgress.config.speed;
        this.trickleSpeed = this._ngProgress.config.trickleSpeed;
        this.started = new core.EventEmitter();
        this.completed = new core.EventEmitter();
    }
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.ngOnChanges = function () {
        if (this.progressRef instanceof NgProgressRef) {
            // Update progress bar config when input changes
            this.progressRef.setConfig({
                max: (this.max > 0 && this.max <= 100) ? this.max : 100,
                min: (this.min < 100 && this.min >= 0) ? this.min : 0,
                speed: this.speed,
                trickleSpeed: this.trickleSpeed,
            });
        }
    };
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.ngOnInit = function () {
        var _this = this;
        // Get progress bar service instance
        this.progressRef = this._ngProgress.ref(this.id, {
            max: this.max,
            min: this.min,
            speed: this.speed,
            trickleSpeed: this.trickleSpeed,
        });
        this.state$ = this.progressRef.state$.pipe(map.map(function (state) { return ({
            active: state.active,
            transform: "translate3d(" + state.value + "%,0,0)"
        }); }));
        /** Subscribes to started and completed events when user used them */
        if (this.started.observers.length) {
            this._started$ = this.progressRef.started.subscribe(function () { return _this.started.next(); });
        }
        if (this.completed.observers.length) {
            this._completed$ = this.progressRef.completed.subscribe(function () { return _this.completed.next(); });
        }
    };
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.ngOnDestroy = function () {
        if (this._started$) {
            this._started$.unsubscribe();
        }
        if (this._completed$) {
            this._completed$.unsubscribe();
        }
        this._ngProgress.destroy(this.id);
    };
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.start = function () {
        this.progressRef.start();
    };
    /**
     * @return {?}
     */
    NgProgressComponent.prototype.complete = function () {
        this.progressRef.complete();
    };
    /**
     * @param {?=} n
     * @return {?}
     */
    NgProgressComponent.prototype.inc = function (n) {
        this.progressRef.inc(n);
    };
    /**
     * @param {?} n
     * @return {?}
     */
    NgProgressComponent.prototype.set = function (n) {
        this.progressRef.set(n);
    };
    Object.defineProperty(NgProgressComponent.prototype, "isStarted", {
        /**
         * @return {?}
         */
        get: function () {
            return this.progressRef.isStarted;
        },
        enumerable: true,
        configurable: true
    });
    return NgProgressComponent;
}());
NgProgressComponent.decorators = [
    { type: core.Component, args: [{
                selector: 'ng-progress',
                host: {
                    'role': 'progressbar',
                    '[attr.spinnerPosition]': 'spinnerPosition',
                    '[attr.dir]': 'direction',
                    '[attr.thick]': 'thick'
                },
                template: "\n    <ng-container *ngIf=\"state$ | async; let state\">\n      <div class=\"ng-progress-bar\"\n            [class.-active]=\"state.active\"\n            [style.transition]=\"'opacity ' + speed + 'ms ' + ease\">\n        <div class=\"ng-bar-placeholder\">\n          <div class=\"ng-bar\"\n                [style.transform]=\"state.transform\"\n                [style.backgroundColor]=\"color\"\n                [style.transition]=\"state.active ? 'all ' + speed + 'ms ' + ease : 'none'\">\n            <div *ngIf=\"meteor\" class=\"ng-meteor\" [style.boxShadow]=\"'0 0 10px '+ color + ', 0 0 5px ' + color\"></div>\n          </div>\n        </div>\n        <div *ngIf=\"spinner\" class=\"ng-spinner\">\n          <div class=\"ng-spinner-icon\"\n                [style.borderTopColor]=\"color\"\n                [style.borderLeftColor]=\"color\"></div>\n        </div>\n      </div>\n    </ng-container>\n  ",
                styles: ["ng-progress{\n  z-index:999999;\n  pointer-events:none;\n  position:relative; }\n.ng-progress-bar{\n  z-index:999999;\n  top:0;\n  left:0;\n  width:100%;\n  position:fixed;\n  zoom:1;\n  filter:alpha(opacity=0);\n  opacity:0; }\n  .ng-progress-bar.-active{\n    filter:alpha(opacity=100);\n    opacity:1;\n    -webkit-transition:none;\n    transition:none; }\n.ng-bar-placeholder{\n  position:absolute;\n  height:2px;\n  width:100%; }\n.ng-bar{\n  width:100%;\n  height:100%;\n  -webkit-transform:translate(-100%, 0, 0);\n          transform:translate(-100%, 0, 0); }\n.ng-meteor{\n  display:block;\n  position:absolute;\n  width:100px;\n  height:100%;\n  opacity:1; }\n.ng-spinner{\n  display:block;\n  position:fixed;\n  z-index:1031;\n  top:15px; }\n.ng-spinner-icon{\n  width:18px;\n  height:18px;\n  -webkit-box-sizing:border-box;\n          box-sizing:border-box;\n  -webkit-animation:spinner-animation 400ms linear infinite;\n          animation:spinner-animation 400ms linear infinite;\n  border:2px solid transparent;\n  border-radius:50%; }\n[dir='ltr+'] .ng-meteor, [dir='ltr-'] .ng-meteor{\n  -webkit-transform:rotate(3deg);\n          transform:rotate(3deg); }\n[dir='ltr+'][thick='true'] .ng-meteor, [dir='ltr-'][thick='true'] .ng-meteor{\n  -webkit-transform:rotate(4deg);\n          transform:rotate(4deg); }\n[dir='ltr+'] .ng-bar, [dir='rtl+'] .ng-bar{\n  margin-left:-100%; }\n[dir='ltr+'] .ng-meteor, [dir='rtl+'] .ng-meteor{\n  right:0; }\n[dir='ltr+'] .ng-meteor, [dir='rtl-'] .ng-meteor{\n  top:-3px; }\n[dir='ltr+'][thick='true'] .ng-meteor, [dir='rtl-'][thick='true'] .ng-meteor{\n  top:-4px; }\n[dir='ltr-'] .ng-meteor, [dir='rtl+'] .ng-meteor{\n  bottom:-3px; }\n[dir='ltr-'][thick='true'] .ng-meteor, [dir='rtl+'][thick='true'] .ng-meteor{\n  bottom:-4px; }\n[dir='ltr-'] .ng-bar-placeholder, [dir='rtl+'] .ng-bar-placeholder{\n  -webkit-transform:rotate(180deg);\n          transform:rotate(180deg); }\n[dir='ltr-'] .ng-spinner-icon, [dir='rtl+'] .ng-spinner-icon{\n  animation-direction:reverse; }\n[dir='rtl+'] .ng-meteor, [dir='rtl-'] .ng-meteor{\n  -webkit-transform:rotate(-3deg);\n          transform:rotate(-3deg); }\n[dir='rtl+'][thick='true'] .ng-meteor, [dir='rtl-'][thick='true'] .ng-meteor{\n  -webkit-transform:rotate(-4deg);\n          transform:rotate(-4deg); }\n[thick='true'] .ng-spinner-icon{\n  width:24px;\n  height:24px;\n  border-width:3px; }\n[thick='true'] .ng-bar-placeholder{\n  height:3px; }\n[spinnerPosition='left'] .ng-spinner{\n  left:15px;\n  right:unset; }\n[spinnerPosition='right'] .ng-spinner{\n  right:15px; }\n@-webkit-keyframes spinner-animation{\n  0%{\n    -webkit-transform:rotate(0deg);\n            transform:rotate(0deg); }\n  100%{\n    -webkit-transform:rotate(360deg);\n            transform:rotate(360deg); } }\n@keyframes spinner-animation{\n  0%{\n    -webkit-transform:rotate(0deg);\n            transform:rotate(0deg); }\n  100%{\n    -webkit-transform:rotate(360deg);\n            transform:rotate(360deg); } }\n"],
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false
            },] },
];
/** @nocollapse */
NgProgressComponent.ctorParameters = function () { return [
    { type: NgProgress, },
]; };
NgProgressComponent.propDecorators = {
    "id": [{ type: core.Input },],
    "spinnerPosition": [{ type: core.Input },],
    "direction": [{ type: core.Input },],
    "ease": [{ type: core.Input },],
    "color": [{ type: core.Input },],
    "meteor": [{ type: core.Input },],
    "spinner": [{ type: core.Input },],
    "thick": [{ type: core.Input },],
    "max": [{ type: core.Input },],
    "min": [{ type: core.Input },],
    "speed": [{ type: core.Input },],
    "trickleSpeed": [{ type: core.Input },],
    "started": [{ type: core.Output },],
    "completed": [{ type: core.Output },],
};
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} config
 * @return {?}
 */
function NgProgressFactory(config) {
    return new NgProgress(config);
}
var NgProgressModule = (function () {
    function NgProgressModule() {
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    NgProgressModule.forRoot = function (config) {
        return {
            ngModule: NgProgressModule,
            providers: [
                { provide: CONFIG, useValue: config },
                {
                    provide: NgProgress,
                    useFactory: NgProgressFactory,
                    deps: [CONFIG]
                }
            ]
        };
    };
    return NgProgressModule;
}());
NgProgressModule.decorators = [
    { type: core.NgModule, args: [{
                declarations: [NgProgressComponent],
                exports: [NgProgressComponent],
                imports: [common.CommonModule]
            },] },
];
/** @nocollapse */
NgProgressModule.ctorParameters = function () { return []; };

exports.NgProgressFactory = NgProgressFactory;
exports.NgProgressModule = NgProgressModule;
exports.NgProgressComponent = NgProgressComponent;
exports.NgProgressRef = NgProgressRef;
exports.NgProgress = NgProgress;
exports.ɵa = CONFIG;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-progressbar-core.umd.js.map
